依赖上方,和左方两个格子











依赖上方,左方,和左上方的格子


        int n=text1.size();
        int m=text2.size();
        for(int i=1;i<=n;i++){
            int leftUp=0,backUp;
            for(int j=1;j<=m;j++){
                backUp=dp[j];
                if(text1[i-1]==text2[j-1]){
                    dp[j]=leftUp+1;
                }else{
                    dp[j]=max(dp[j],dp[j-1]);
                }
                leftUp=backUp;

            }
        }
        return dp[m];


区间dp空间压缩


  int n=s.size();
        int dp[1005];
        for(int l=n-1;l>=0;l--){
            int leftdown=0,backup;
            dp[l]=1;
            if(l+1<n)
            {
                leftdown=dp[l+1];
               dp[l+1]=(s[l]==s[l+1]?2:1);
               
            }
            for(int r=l+2;r<n;r++){
                int backup=dp[r];
                if(s[l]==s[r]){
                    dp[r]=leftdown+2;
                }else{
                    dp[r]=max(dp[r],dp[r-1]);
                }
                leftdown=backup;

            }
        }
        return dp[n-1];


依赖 上方和左上方



  int dp[1005];
        int mod=1e9+7;

        int n=s.size();
        int m=t.size();
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=m;j>=1;j--){
                dp[j]=dp[j];
                if(s[i-1]==t[j-1]){
                    dp[j]=(dp[j]+dp[j-1])%mod;
                }
            }
        }
        return dp[m]%mod;
